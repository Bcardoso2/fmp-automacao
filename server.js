require('dotenv').config()
const express = require('express')
const { Pool } = require('pg')
const bcrypt = require('bcrypt')
const crypto = require('crypto')
const makeWASocket = require('@whiskeysockets/baileys').default
const { 
  useMultiFileAuthState,
  DisconnectReason,
  fetchLatestBaileysVersion,
  makeCacheableSignalKeyStore
} = require('@whiskeysockets/baileys')
const pino = require('pino')
const NodeCache = require('node-cache')

// ============================================
// CONFIGURA√á√ïES
// ============================================
const app = express()
const PORT = Number(process.env.PORT || 3000)
const NOTIFY_NUMBER = (process.env.NOTIFY_NUMBER || '559193718097').replace(/\D/g, '')
const DATABASE_URL = process.env.DATABASE_URL || 'postgresql://autogiro_user:yewPi2fnUONvMTf20gWcz4cN2MgiVw7D@dpg-d3ff4gali9vc73f4h0tg-a.oregon-postgres.render.com:5432/autogiro'
const WA_DATA_PATH = process.env.WA_DATA_PATH || './auth_info_baileys'
const HUBLA_WEBHOOK_TOKEN = process.env.HUBLA_WEBHOOK_TOKEN || ''

if (!DATABASE_URL) {
  console.error('‚ùå DATABASE_URL n√£o configurado')
  process.exit(1)
}

if (!HUBLA_WEBHOOK_TOKEN) {
  console.warn('‚ö†Ô∏è HUBLA_WEBHOOK_TOKEN n√£o configurado - webhook sem autentica√ß√£o!')
}

const pool = new Pool({
  connectionString: DATABASE_URL,
  ssl: { rejectUnauthorized: false }
})

// ============================================
// ESTADO GLOBAL WHATSAPP + FILA
// ============================================
let sock = null
let isWhatsappReady = false
let reconnectTimeout = null
let isInitializingWhatsapp = false
let hasStartedWhatsapp = false
let qrAttempts = 0
const MAX_QR_ATTEMPTS = 3
let currentQRCode = null

const msgRetryCounterCache = new NodeCache()

// Fila de mensagens
const messageQueue = []
function enqueueMessage(number, message) {
  messageQueue.push({ number, message })
  console.log(`üì¨ Mensagem enfileirada. Total na fila: ${messageQueue.length}`)
}

async function flushMessageQueue() {
  if (!isWhatsappReady || !sock) return
  console.log(`üì§ Processando ${messageQueue.length} mensagens da fila...`)
  
  while (messageQueue.length > 0) {
    const { number, message } = messageQueue.shift()
    try {
      const jid = `${number}@s.whatsapp.net`
      await sock.sendMessage(jid, { text: message })
      console.log(`‚úÖ Mensagem da fila enviada para ${number}`)
      await new Promise(resolve => setTimeout(resolve, 1000))
    } catch (err) {
      console.error('‚ùå Falha ao enviar mensagem da fila:', err?.message || err)
    }
  }
}

// ============================================
// MIDDLEWARES
// ============================================
app.use(express.json({ limit: '1mb' }))
app.use(express.urlencoded({ extended: true }))

app.use((req, res, next) => {
  req.requestId = crypto.randomBytes(8).toString('hex')
  res.setHeader('X-Request-Id', req.requestId)
  console.log(`‚û°Ô∏è  ${req.method} ${req.url} [${req.requestId}]`)
  res.on('finish', () => {
    console.log(`‚¨ÖÔ∏è  ${req.method} ${req.url} [${req.requestId}] ${res.statusCode}`)
  })
  next()
})

// ============================================
// FUN√á√ïES DO BANCO DE DADOS
// ============================================
async function queryDB(text, params) {
  const start = Date.now()
  const res = await pool.query(text, params)
  const duration = Date.now() - start
  console.log('üîç Query executada:', { durationMs: duration, rows: res.rowCount })
  return res
}

async function deactivateUserInDB(phone) {
  try {
    const result = await queryDB(`
      UPDATE users 
      SET is_active = false 
      WHERE phone = $1 
      RETURNING id, phone, name, email, is_active
    `, [phone])

    if (result.rowCount > 0) {
      const user = result.rows[0]
      console.log(`üî¥ Usu√°rio desativado: ${user.name} (ID: ${user.id})`)
      return { success: true, user }
    } else {
      console.log(`‚ö†Ô∏è Usu√°rio n√£o encontrado no banco: ${phone}`)
      return { success: false, error: 'Usu√°rio n√£o encontrado' }
    }
  } catch (error) {
    console.error('‚ùå Erro ao desativar usu√°rio:', error.message)
    return { success: false, error: error.message }
  }
}

async function findUserByPhone(phone) {
  try {
    const result = await queryDB(
      'SELECT id, phone, name, email, credits, role, is_active, created_at FROM users WHERE phone = $1 LIMIT 1',
      [phone]
    )
    return result.rowCount > 0 ? result.rows[0] : null
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio:', error.message)
    return null
  }
}

async function createUserInDB(userData) {
  try {
    const { phone, password, name, email, clientId, credits = 0 } = userData

    if (!phone || !name) {
      throw new Error('Dados obrigat√≥rios faltando: phone, name')
    }

    // Verifica se usu√°rio j√° existe
    const existing = await findUserByPhone(phone)
    if (existing) {
      console.log('‚ÑπÔ∏è Usu√°rio j√° existe, retornando existente:', existing.id)
      return { success: true, user: existing, code: 'ALREADY_EXISTS' }
    }

    const tempPassword = password && password.length >= 6 ? password : generateRandomPassword()
    const passwordHash = await bcrypt.hash(tempPassword, 10)

    const result = await queryDB(`
      INSERT INTO users (phone, password_hash, name, email, client_id, credits, role, is_active)
      VALUES ($1, $2, $3, $4, $5, $6, 'viewer', true)
      RETURNING id, phone, name, email, credits, role, created_at
    `, [phone, passwordHash, name, email || null, clientId || 'client1', credits])

    const user = result.rows[0]
    user.tempPassword = tempPassword
    
    console.log('‚úÖ Usu√°rio criado com sucesso:', user)

    return { success: true, user }
  } catch (error) {
    console.error('‚ùå Erro ao criar usu√°rio:', error.message)

    if (error.code === '23505') {
      return {
        success: false,
        error: 'Usu√°rio j√° existe no banco de dados',
        code: 'DUPLICATE_USER'
      }
    }

    return { success: false, error: error.message }
  }
}

// ============================================
// WHATSAPP BAILEYS
// ============================================
function scheduleReconnect(delayMs = 5000) {
  if (reconnectTimeout) {
    console.log('‚è≥ Reconex√£o j√° agendada, ignorando...')
    return
  }
  
  const delaySec = Math.floor(delayMs / 1000)
  console.log(`üîÑ Agendando reconex√£o em ${delaySec} segundos...`)
  
  reconnectTimeout = setTimeout(() => {
    reconnectTimeout = null
    console.log('üîÑ Iniciando reconex√£o...')
    initWhatsApp(true).catch(err => {
      console.error('‚ùå Erro ao reconectar:', err?.message || err)
      scheduleReconnect(Math.min(delayMs * 1.5, 60000))
    })
  }, delayMs)
}

async function connectToWhatsApp() {
  const { state, saveCreds } = await useMultiFileAuthState(WA_DATA_PATH)
  const { version } = await fetchLatestBaileysVersion()
  
  console.log(`üì± Usando vers√£o do WhatsApp: ${version.join('.')}`)
  
  sock = makeWASocket({
    version,
    auth: {
      creds: state.creds,
      keys: makeCacheableSignalKeyStore(state.keys, pino({ level: 'silent' }))
    },
    logger: pino({ level: 'silent' }),
    msgRetryCounterCache,
    generateHighQualityLinkPreview: true,
    browser: ['AutoGiro', 'Chrome', '4.0.0'],
    getMessage: async (key) => {
      return { conversation: '' }
    }
  })

  sock.ev.on('creds.update', saveCreds)
  
  sock.ev.on('connection.update', async (update) => {
    const { connection, lastDisconnect, qr } = update
    
    if (qr) {
      qrAttempts++
      currentQRCode = qr
      
      console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)
      console.log(`üì± QR CODE GERADO (Tentativa ${qrAttempts}/${MAX_QR_ATTEMPTS})`)
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)
      console.log(`üåê ACESSE PELO NAVEGADOR:`)
      console.log(`   üëâ https://automacao-autogiro.onrender.com/qr`)
      console.log(`   üëâ http://localhost:${PORT}/qr`)
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`)
      
      if (qrAttempts >= MAX_QR_ATTEMPTS) {
        console.log('‚ö†Ô∏è Muitas tentativas de QR Code. Reiniciando conex√£o...')
        qrAttempts = 0
        currentQRCode = null
        if (sock) sock.end(undefined)
        scheduleReconnect(10000)
      }
    }
    
    if (connection === 'close') {
      const statusCode = lastDisconnect?.error?.output?.statusCode
      const reason = lastDisconnect?.error?.message || 'Desconhecido'
      
      console.log('‚ùå Conex√£o fechada')
      console.log('   Motivo:', reason)
      console.log('   Status Code:', statusCode)
      
      isWhatsappReady = false
      qrAttempts = 0
      
      const shouldReconnect = statusCode !== DisconnectReason.loggedOut
      
      if (statusCode === DisconnectReason.loggedOut) {
        console.log('‚ö†Ô∏è Voc√™ foi deslogado do WhatsApp')
        console.log(`‚ö†Ô∏è Delete a pasta "${WA_DATA_PATH}" e reinicie o servidor`)
      } else if (shouldReconnect) {
        console.log('üîÑ Tentando reconectar...')
        scheduleReconnect(5000)
      }
    } else if (connection === 'open') {
      console.log('‚úÖ WhatsApp conectado com sucesso!')
      isWhatsappReady = true
      qrAttempts = 0
      
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout)
        reconnectTimeout = null
      }
      
      setTimeout(() => {
        flushMessageQueue().catch(err => {
          console.error('‚ùå Erro ao processar fila:', err)
        })
      }, 2000)
    } else if (connection === 'connecting') {
      console.log('üîÑ Conectando ao WhatsApp...')
    }
  })
  
  return sock
}

async function initWhatsApp(isReconnect = false) {
  if (isInitializingWhatsapp) {
    console.log('‚è≥ J√° est√° inicializando WhatsApp, ignorando...')
    return
  }
  
  if (!isReconnect && hasStartedWhatsapp) {
    console.log('‚è≥ WhatsApp j√° foi iniciado anteriormente')
    return
  }
  
  isInitializingWhatsapp = true
  
  try {
    if (sock) {
      try {
        sock.end(undefined)
      } catch (e) {
        console.warn('‚ö†Ô∏è Erro ao encerrar socket anterior:', e?.message)
      }
      sock = null
      isWhatsappReady = false
    }
    
    console.log('üì± Iniciando Baileys...')
    await connectToWhatsApp()
    hasStartedWhatsapp = true
    
  } catch (error) {
    console.error('‚ùå Erro ao inicializar Baileys:', error?.message || error)
    scheduleReconnect(10000)
  } finally {
    isInitializingWhatsapp = false
  }
}

async function sendWhatsAppMessage(number, message) {
  try {
    if (!number || !/^\d{10,15}$/.test(number)) {
      throw new Error('N√∫mero de telefone inv√°lido')
    }
    if (!message || typeof message !== 'string') {
      throw new Error('Mensagem inv√°lida')
    }
    if (!sock) {
      throw new Error('Socket WhatsApp n√£o inicializado')
    }
    if (!isWhatsappReady) {
      console.log('‚ÑπÔ∏è WhatsApp n√£o pronto, enfileirando mensagem...')
      enqueueMessage(number, message)
      return { success: true, queued: true }
    }

    const jid = `${number}@s.whatsapp.net`
    await sock.sendMessage(jid, { text: message })
    console.log(`‚úÖ Mensagem enviada para ${number}`)
    
    return { success: true }
  } catch (error) {
    console.error('‚ùå Erro ao enviar mensagem:', error.message)
    return { success: false, error: error.message }
  }
}

// ============================================
// FORMATA√á√ÉO DE MENSAGENS
// ============================================
function formatWelcomeMessage(user, webhookData) {
  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product
  
  return `üéâ *Bem-vindo(a) ao AutoGiro!*

Ol√° *${user.name}*! üëã

Sua assinatura foi ativada com sucesso! üéä

üì¶ *Detalhes da Assinatura Hub.la:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Validade: ${subscription?.credits || 0} dias
üîÑ Renova√ß√£o Autom√°tica: ${subscription?.autoRenew ? 'Ativada ‚úÖ' : 'Desativada'}

üîê *Seus Dados de Acesso:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì± Telefone: ${user.phone}
üìß Email: ${user.email || 'N√£o informado'}
üîë Senha Tempor√°ria: *${user.tempPassword}*

üí∞ *Saldo de Cr√©ditos no Sistema:*
Cr√©ditos dispon√≠veis: ${user.credits} (use dentro da plataforma)

‚ö†Ô∏è *IMPORTANTE:* Por seguran√ßa, altere sua senha no primeiro acesso!

üíª *Como acessar:*
1. Acesse a plataforma
2. Fa√ßa login com seu telefone/email
3. Use a senha tempor√°ria acima
4. Altere para uma senha pessoal

Qualquer d√∫vida, estamos √† disposi√ß√£o! 

Aproveite sua assinatura! üöÄ

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Obrigado por escolher nossos servi√ßos!_`
}

function formatExpiringMessage(user, webhookData) {
  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product
  const daysRemaining = subscription?.credits || 0
  
  return `‚ö†Ô∏è *Sua Assinatura Est√° Expirando!*

Ol√° *${user.name}*! 

Queremos avisar que sua assinatura est√° perto de expirar.

üì¶ *Detalhes da Assinatura:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Dias Restantes: *${daysRemaining} dias*
üîÑ Renova√ß√£o Autom√°tica: ${subscription?.autoRenew ? 'ATIVADA ‚úÖ' : 'DESATIVADA ‚ùå'}

${subscription?.autoRenew 
  ? `‚úÖ *N√£o se preocupe!*
Sua assinatura ser√° renovada automaticamente antes de expirar.
Voc√™ n√£o perder√° o acesso aos servi√ßos.`
  : `‚ö†Ô∏è *ATEN√á√ÉO!*
Sua renova√ß√£o autom√°tica est√° DESATIVADA.
Para n√£o perder o acesso, renove sua assinatura antes do vencimento.

üîÑ *Como renovar:*
1. Acesse a plataforma Hub.la
2. V√° em "Minhas Assinaturas"
3. Clique em "Renovar"`
}

üí° *Precisa de ajuda?*
Entre em contato com nosso suporte.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sua satisfa√ß√£o √© nossa prioridade!_`
}

function formatDeactivatedMessage(user, webhookData) {
  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product
  
  return `üî¥ *Assinatura Expirada*

Ol√° *${user.name}*,

Sua assinatura do AutoGiro expirou e seu acesso foi desativado.

üì¶ *Detalhes:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Status: *EXPIRADA*
üìÖ Desativada em: ${new Date().toLocaleDateString('pt-BR')}

üòî *O que acontece agora?*
‚Ä¢ Seu acesso √† plataforma foi suspenso
‚Ä¢ Seus dados est√£o seguros e preservados
‚Ä¢ Voc√™ pode renovar a qualquer momento

üíö *Como renovar e reativar:*
1. Acesse a plataforma Hub.la
2. Fa√ßa login com suas credenciais
3. V√° em "Minhas Assinaturas"
4. Clique em "Renovar Assinatura"

‚ú® Ap√≥s a renova√ß√£o, seu acesso ser√° reativado automaticamente!

üìû *Precisa de ajuda?*
Nossa equipe est√° pronta para ajudar voc√™!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Esperamos voc√™ de volta!_`
}

function formatDeactivatedNotificationAdmin(user, webhookData) {
  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product
  const timestamp = new Date().toLocaleString('pt-BR', {
    timeZone: 'America/Belem'
  })

  return `üî¥ *ASSINATURA DESATIVADA - A√á√ÉO NECESS√ÅRIA*

‚ö†Ô∏è Cliente teve assinatura desativada por falta de cr√©ditos!

üë§ *Dados do Cliente:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Nome: *${user.name}*
üì± Telefone: ${user.phone}
üìß Email: ${user.email || 'N√£o informado'}
üÜî ID Banco: ${user.id || 'N/A'}

üì¶ *Detalhes da Assinatura:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Cr√©ditos: ${subscription?.credits || 0} (ZERADO)
üîÑ Auto-Renova√ß√£o: ${subscription?.autoRenew ? 'ESTAVA ATIVA' : 'INATIVA'}
üìÖ ID Assinatura: ${subscription?.id || 'N/A'}
üïê Desativada em: ${timestamp}

üéØ *A√á√ÉO NECESS√ÅRIA:*
${user.id 
  ? `‚úÖ Usu√°rio foi desativado automaticamente no banco de dados.
‚ö†Ô∏è Remover acesso do cliente aos sistemas/grupos.`
  : `‚ö†Ô∏è Usu√°rio n√£o est√° cadastrado no banco.
‚ÑπÔ∏è Apenas notifica√ß√£o enviada ao cliente.`
}

üìå *Pr√≥ximos passos:*
1. Remover cliente de grupos/canais privados
2. Desativar acessos especiais
3. Aguardar renova√ß√£o do cliente

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`
}

function formatAbandonedCheckoutMessage(lead, products) {
  const productNames = products.map(p => p.name).join(', ')
  const firstName = lead.fullName ? lead.fullName.split(' ')[0] : 'Cliente'
  
  return `üõí *Ei, ${firstName}!* 

Notamos que voc√™ estava quase finalizando sua compra mas algo aconteceu... üòä

üì¶ *Produtos no carrinho:*
${productNames}

‚è∞ *N√£o perca essa oportunidade!*

Sabemos que imprevistos acontecem. Estamos aqui para ajudar voc√™ a finalizar sua compra!

üí° *Benef√≠cios de assinar agora:*
‚úÖ Acesso imediato √† plataforma
‚úÖ Suporte dedicado
‚úÖ Todas as funcionalidades liberadas
‚úÖ Pagamento seguro

üîó *Finalize sua compra:*
${lead.session?.url || 'Acesse o link que voc√™ recebeu por email'}

‚ùì *Alguma d√∫vida?*
Responda esta mensagem que teremos prazer em ajudar!

Estamos te esperando! üöÄ

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Estamos aqui para voc√™!_`
}

function formatAbandonedCheckoutNotificationAdmin(lead, products, webhookData) {
  const timestamp = new Date().toLocaleString('pt-BR', {
    timeZone: 'America/Belem'
  })
  
  const productsList = products.map(p => 
    `üì¶ ${p.name} (ID: ${p.id})`
  ).join('\n')

  const utmInfo = lead.session?.utm ? `
üìä *Origem do Tr√°fego (UTM):*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîπ Source: ${lead.session.utm.source || 'N/A'}
üîπ Medium: ${lead.session.utm.medium || 'N/A'}
üîπ Campaign: ${lead.session.utm.campaign || 'N/A'}
üîπ Content: ${lead.session.utm.content || 'N/A'}
üîπ Term: ${lead.session.utm.term || 'N/A'}` : ''

  const cookiesInfo = lead.session?.cookies ? `
üç™ *Cookies/IDs:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Facebook Pixel: ${lead.session.cookies.fbp ? '‚úÖ' : '‚ùå'}
‚Ä¢ Google Click ID: ${lead.session.cookies.gclid ? '‚úÖ' : '‚ùå'}
‚Ä¢ Hub.la ID: ${lead.session.cookies.hbId || 'N/A'}` : ''

  return `üõí *CARRINHO ABANDONADO - LEAD QUENTE!*

‚ö†Ô∏è Potencial cliente abandonou o checkout ap√≥s preencher dados!

üë§ *Dados do Lead:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Nome: *${lead.fullName || 'N√£o informado'}*
üì± Telefone: ${lead.phone || 'N√£o informado'}
üìß Email: ${lead.email || 'N√£o informado'}
üÜî Lead ID: ${lead.id}
üïê Abandonado em: ${timestamp}

üì¶ *Produtos no Carrinho:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${productsList}
${utmInfo}
${cookiesInfo}

üîó *URL do Checkout:*
${lead.session?.url || 'N/A'}

üí° *A√á√ÉO SUGERIDA:*
‚úÖ Mensagem de recupera√ß√£o enviada automaticamente ao cliente
üìû Considere fazer follow-up personalizado em 1-2 horas
üí¨ Cliente demonstrou interesse - est√° pronto para converter!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`
}

function formatUserCreatedMessage(user, webhookData) {
  const timestamp = new Date().toLocaleString('pt-BR', {
    timeZone: 'America/Belem'
  })

  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product

  return `ü§ñ *NOVA ASSINATURA ATIVADA*

‚úÖ Usu√°rio registrado com sucesso no banco de dados!

üìã *Dados do Usu√°rio:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ Nome: ${user.name}
üì± Telefone: ${user.phone}
üìß Email: ${user.email || 'N√£o informado'}
üÜî ID no Banco: ${user.id}
üîë Senha Gerada: *${user.tempPassword || 'N/A'}*
üí∞ Cr√©ditos Sistema: ${user.credits}

üí≥ *Dados da Assinatura Hub.la:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Validade: ${subscription?.credits || 0} dias
üíµ Pagamento: ${subscription?.paymentMethod === 'credit_card' ? 'Cart√£o de Cr√©dito' : subscription?.paymentMethod || 'N/A'}
üîÑ Renova√ß√£o: ${subscription?.autoRenew ? 'Sim' : 'N√£o'}
üìÖ Ativada em: ${timestamp}

‚úâÔ∏è *Mensagem de boas-vindas enviada ao cliente!*

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`
}

function formatExpiringNotificationAdmin(user, webhookData) {
  const subscription = webhookData?.event?.subscription
  const product = webhookData?.event?.product
  const daysRemaining = subscription?.credits || 0

  return `‚ö†Ô∏è *ASSINATURA EXPIRANDO - ALERTA*

Cliente: *${user.name}*
Telefone: ${user.phone}
Email: ${user.email || 'N√£o informado'}

üì¶ *Detalhes:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì¶ Produto: ${product?.name || 'N/A'}
‚è∞ Dias Restantes: *${daysRemaining} dias*
üîÑ Auto-Renova√ß√£o: ${subscription?.autoRenew ? 'SIM ‚úÖ' : 'N√ÉO ‚ùå'}
üìÖ ID Assinatura: ${subscription?.id || 'N/A'}

${!subscription?.autoRenew ? '‚ö†Ô∏è *ATEN√á√ÉO:* Cliente sem renova√ß√£o autom√°tica!' : '‚úÖ Renova√ß√£o autom√°tica ativada.'}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`
}

async function notifyError(error, userData) {
  try {
    if (!NOTIFY_NUMBER) return
    const message = `‚ö†Ô∏è *ERRO AO PROCESSAR WEBHOOK*

‚ùå Houve um problema ao processar o webhook.

üìã *Dados recebidos:*
${JSON.stringify(userData, null, 2)}

üî¥ *Erro:*
${error}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`
    await sendWhatsAppMessage(NOTIFY_NUMBER, message)
  } catch (err) {
    console.error('‚ùå Erro ao enviar notifica√ß√£o de erro:', err)
  }
}

function mapHublaDataToUser(webhookData) {
  if (!webhookData?.event?.user) {
    throw new Error('Formato de webhook inv√°lido - dados do usu√°rio n√£o encontrados')
  }

  const { user, subscription, product } = webhookData.event
  const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim()
  const rawPhone = user.phone || ''
  const cleanPhone = rawPhone.replace(/\D/g, '')

  if (!cleanPhone) {
    throw new Error('Telefone ausente ou inv√°lido no webhook')
  }
  if (!fullName) {
    throw new Error('Nome ausente no webhook')
  }

  return {
    phone: cleanPhone,
    password: generateRandomPassword(),
    name: fullName,
    email: user.email,
    clientId: subscription?.id || 'hubla_' + String(user.id || '').slice(0, 8),
    credits: 0,
    hublaUserId: user.id,
    hublaSubscriptionId: subscription?.id,
    hublaProductName: product?.name,
    hublaSubscriptionCredits: subscription?.credits,
    document: user.document
  }
}

function generateRandomPassword() {
  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  let password = ''
  for (let i = 0; i < 8; i++) {
    password += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return password
}

// ============================================
// ROTAS
// ============================================
app.get('/', (req, res) => {
  res.json({
    status: 'ok',
    message: 'Servidor AutoGiro rodando com Baileys!',
    whatsapp: isWhatsappReady ? 'conectado' : 'desconectado',
    queueSize: messageQueue.length
  })
})

app.get('/qr', (req, res) => {
  if (!currentQRCode) {
    return res.send(`
      <html>
        <body style="font-family: Arial; text-align: center; padding: 50px;">
          <h2>‚è≥ Aguardando QR Code...</h2>
          <p>O WhatsApp ainda n√£o gerou um QR Code.</p>
          <button onclick="location.reload()">üîÑ Recarregar</button>
        </body>
      </html>
    `)
  }

  const QRCode = require('qrcode')
  QRCode.toDataURL(currentQRCode, (err, url) => {
    res.send(`
      <html>
        <head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            body {
              font-family: Arial, sans-serif;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              min-height: 100vh;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              margin: 0;
              padding: 20px;
            }
            .container {
              background: white;
              padding: 40px;
              border-radius: 20px;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
              text-align: center;
              max-width: 500px;
            }
            h1 { color: #333; margin-bottom: 10px; }
            p { color: #666; margin-bottom: 30px; }
            img { 
              border-radius: 12px;
              box-shadow: 0 4px 6px rgba(0,0,0,0.1);
              max-width: 100%;
              height: auto;
            }
            .steps {
              text-align: left;
              background: #f8f9fa;
              padding: 20px;
              border-radius: 12px;
              margin-top: 20px;
            }
            .steps ol { margin-left: 20px; }
            .steps li { margin: 10px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>üì± WhatsApp QR Code</h1>
            <p>Escaneie com seu WhatsApp</p>
            <img src="${url}" alt="QR Code">
            <div class="steps">
              <strong>Como conectar:</strong>
              <ol>
                <li>Abra o WhatsApp no celular</li>
                <li>Toque em Menu (‚ãÆ) > Aparelhos conectados</li>
                <li>Toque em "Conectar um aparelho"</li>
                <li>Escaneie este QR Code</li>
              </ol>
            </div>
          </div>
        </body>
      </html>
    `)
  })
})

app.get('/health', async (req, res) => {
  const healthCheck = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    service: 'AutoGiro',
    version: '1.0.0',
    checks: {
      server: 'healthy',
      database: 'checking',
      whatsapp: 'checking',
      messageQueue: messageQueue.length
    }
  }

  try {
    const dbStart = Date.now()
    await pool.query('SELECT 1')
    const dbLatency = Date.now() - dbStart
    
    healthCheck.checks.database = 'healthy'
    healthCheck.checks.databaseLatency = `${dbLatency}ms`
  } catch (error) {
    healthCheck.status = 'degraded'
    healthCheck.checks.database = 'unhealthy'
    healthCheck.checks.databaseError = error.message
  }

  if (isWhatsappReady && sock) {
    healthCheck.checks.whatsapp = 'connected'
  } else if (isInitializingWhatsapp) {
    healthCheck.checks.whatsapp = 'connecting'
    healthCheck.status = 'degraded'
  } else {
    healthCheck.checks.whatsapp = 'disconnected'
    healthCheck.status = 'degraded'
  }

  if (messageQueue.length > 100) {
    healthCheck.status = 'degraded'
    healthCheck.checks.messageQueueStatus = 'warning - queue too large'
  } else {
    healthCheck.checks.messageQueueStatus = 'normal'
  }

  const statusCode = healthCheck.status === 'ok' ? 200 : 503
  res.status(statusCode).json(healthCheck)
})

app.get('/ping', (req, res) => {
  res.status(200).json({
    status: 'ok',
    message: 'pong',
    timestamp: new Date().toISOString()
  })
})

app.get('/status', async (req, res) => {
  let dbStatus = 'desconectado'
  try {
    await pool.query('SELECT 1')
    dbStatus = 'conectado'
  } catch {
    dbStatus = 'desconectado'
  }
  res.json({
    server: 'online',
    whatsapp: isWhatsappReady ? 'conectado' : 'desconectado',
    database: dbStatus,
    messageQueue: messageQueue.length
  })
})

app.get('/api/users', async (req, res) => {
  try {
    const result = await queryDB(`
      SELECT id, phone, name, email, credits, role, is_active, created_at
      FROM users
      ORDER BY created_at DESC
    `)
    
    res.json(result.rows)
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rios:', error)
    res.status(500).json({ error: 'Erro ao buscar usu√°rios' })
  }
})

app.get('/dashboard', (req, res) => {
  res.sendFile(__dirname + '/dashboard.html')
})

app.post('/api/users/:id/add-credits', async (req, res) => {
  try {
    const userId = req.params.id
    const { amount, reason } = req.body

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Quantidade de cr√©ditos inv√°lida' })
    }

    const result = await queryDB(`
      UPDATE users 
      SET credits = credits + $1 
      WHERE id = $2 
      RETURNING id, name, phone, credits
    `, [amount, userId])

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' })
    }

    const user = result.rows[0]
    console.log(`üí∞ Cr√©ditos adicionados: ${amount} para usu√°rio ${user.name} (ID: ${userId})`)

    const message = `üí∞ *Cr√©ditos Adicionados!*

Ol√° *${user.name}*! 

Voc√™ recebeu *${amount} cr√©ditos* em sua conta! üéâ

üìä *Seu saldo atual:*
üí∞ ${user.credits} cr√©ditos

${reason ? `üìù Motivo: ${reason}` : ''}

Aproveite! üöÄ

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema de Cr√©ditos_`

    await sendWhatsAppMessage(user.phone, message)

    res.json({
      success: true,
      message: 'Cr√©ditos adicionados com sucesso',
      user
    })
  } catch (error) {
    console.error('‚ùå Erro ao adicionar cr√©ditos:', error)
    res.status(500).json({ error: 'Erro ao adicionar cr√©ditos' })
  }
})

app.post('/api/users/:id/use-credits', async (req, res) => {
  try {
    const userId = req.params.id
    const { amount, service } = req.body

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Quantidade de cr√©ditos inv√°lida' })
    }

    const checkBalance = await queryDB(
      'SELECT credits FROM users WHERE id = $1',
      [userId]
    )

    if (checkBalance.rowCount === 0) {
      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' })
    }

    const currentCredits = checkBalance.rows[0].credits

    if (currentCredits < amount) {
      return res.status(400).json({ 
        error: 'Cr√©ditos insuficientes',
        available: currentCredits,
        required: amount
      })
    }

    const result = await queryDB(`
      UPDATE users 
      SET credits = credits - $1 
      WHERE id = $2 
      RETURNING id, name, phone, credits
    `, [amount, userId])

    const user = result.rows[0]
    console.log(`üìâ Cr√©ditos consumidos: ${amount} do usu√°rio ${user.name} (ID: ${userId})`)

    res.json({
      success: true,
      message: 'Cr√©ditos consumidos com sucesso',
      user,
      consumed: amount,
      remaining: user.credits
    })
  } catch (error) {
    console.error('‚ùå Erro ao consumir cr√©ditos:', error)
    res.status(500).json({ error: 'Erro ao consumir cr√©ditos' })
  }
})

// ============================================
// FUN√á√ÉO AUXILIAR: NORMALIZAR TELEFONE (HUB.LA)
// ============================================
function normalizePhone(phone) {
  if (!phone) return null
  
  // Remove tudo que n√£o √© n√∫mero
  let clean = String(phone).replace(/\D/g, '')
  
  // Remove zeros √† esquerda
  clean = clean.replace(/^0+/, '')
  
  // Remove DDI 55 duplicado (ex: 5555119... -> 55119...)
  if (clean.startsWith('5555') && clean.length > 12) {
    clean = '55' + clean.substring(4)
  }
  
  // Se tem mais de 13 d√≠gitos, pega os √∫ltimos 13
  if (clean.length > 13) {
    clean = clean.slice(-13)
  }
  
  // Se j√° tem 13 d√≠gitos e come√ßa com 55, est√° OK
  if (clean.length === 13 && clean.startsWith('55')) {
    return clean
  }
  
  // Se tem 12 d√≠gitos e come√ßa com 55, est√° OK
  if (clean.length === 12 && clean.startsWith('55')) {
    return clean
  }
  
  // Se tem 11 d√≠gitos (DDD + n√∫mero), adiciona DDI 55
  if (clean.length === 11) {
    return '55' + clean
  }
  
  // Se tem 10 d√≠gitos (DDD + n√∫mero sem o 9), adiciona DDI 55
  if (clean.length === 10) {
    return '55' + clean
  }
  
  // Formato inv√°lido
  return null
}

// ============================================
// FUN√á√ÉO AUXILIAR: MAPEAR CAMPOS DA HUB.LA
// ============================================
function mapHublaContact(contact) {
  // Mapeamento de colunas da Hub.la para formato padr√£o
  const mapped = {
    // Nomes poss√≠veis
    nome: contact['Nome do cliente'] || 
          contact['nome'] || 
          contact['name'] || 
          contact['Nome'] || 
          '',
    
    // Telefones poss√≠veis
    telefone: contact['Telefone do cliente'] || 
              contact['telefone'] || 
              contact['phone'] || 
              contact['tel'] || 
              contact['whatsapp'] || 
              '',
    
    // Emails poss√≠veis
    email: contact['Email do cliente'] || 
           contact['email'] || 
           contact['e-mail'] || 
           '',
    
    // CPF/Documento
    cpf: contact['Documento do cliente'] || 
         contact['cpf'] || 
         contact['documento'] || 
         '',
    
    // Status
    status: contact['Status da assinatura'] || 
            contact['status'] || 
            '',
    
    // Plano
    plano: contact['Plano'] || 
           contact['plano'] || 
           '',
    
    // Produto
    produto: contact['Nome do produto'] || 
             contact['produto'] || 
             contact['product'] || 
             ''
  }
  
  // Retorna o objeto mapeado com todos os campos originais tamb√©m
  return { ...contact, ...mapped }
}

// ============================================
// ROTA DE ENVIO EM MASSA
// ============================================
app.post('/api/bulk-send', async (req, res) => {
  try {
    const { contacts, message, delaySeconds = 3 } = req.body

    console.log('üì¨ Iniciando envio em massa...')
    console.log(`   Total de contatos: ${contacts?.length || 0}`)
    console.log(`   Intervalo: ${delaySeconds}s`)

    // Valida√ß√µes b√°sicas
    if (!contacts || !Array.isArray(contacts) || contacts.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Nenhum contato fornecido'
      })
    }

    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Mensagem inv√°lida ou vazia'
      })
    }

    // Processar contatos e separar v√°lidos/inv√°lidos
    const validContacts = []
    const invalidContacts = []

    contacts.forEach((contact, index) => {
      // Mapeia campos da Hub.la para formato padr√£o
      const mappedContact = mapHublaContact(contact)
      
      // Tenta encontrar o campo de telefone
      const phoneField = mappedContact.telefone
      
      if (!phoneField) {
        invalidContacts.push({ 
          index, 
          reason: 'Telefone ausente', 
          data: contact,
          nome: mappedContact.nome 
        })
        return
      }

      // USA A FUN√á√ÉO DE NORMALIZA√á√ÉO
      const cleanPhone = normalizePhone(phoneField)
      
      if (!cleanPhone) {
        invalidContacts.push({ 
          index, 
          reason: 'Formato inv√°lido', 
          phone: phoneField, 
          data: contact,
          nome: mappedContact.nome
        })
        return
      }

      validContacts.push({
        phone: cleanPhone,
        data: mappedContact  // Usa os dados mapeados
      })
    })

    console.log(`‚úÖ Contatos v√°lidos: ${validContacts.length}`)
    console.log(`‚ùå Contatos inv√°lidos: ${invalidContacts.length}`)

    // Se n√£o houver contatos v√°lidos, retornar erro
    if (validContacts.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Nenhum contato v√°lido encontrado',
        total: contacts.length,
        valid: 0,
        invalid: invalidContacts.length,
        invalidContacts: invalidContacts
      })
    }

    // Responder imediatamente ao frontend
    res.status(200).json({
      success: true,
      message: 'Envio em massa iniciado',
      total: contacts.length,
      valid: validContacts.length,
      invalid: invalidContacts.length
    })

    // Processar envios em background (n√£o bloqueia a resposta)
    console.log('üöÄ Iniciando envios em background...')
    
    processQueueInBackground(validContacts, message, delaySeconds)

  } catch (error) {
    console.error('‚ùå Erro na rota /api/bulk-send:', error)
    return res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: error.message
    })
  }
})

// ============================================
// FUN√á√ÉO AUXILIAR: PROCESSAR FILA EM BACKGROUND
// ============================================
async function processQueueInBackground(validContacts, messageTemplate, delaySeconds) {
  let successCount = 0
  let failCount = 0

  for (let i = 0; i < validContacts.length; i++) {
    const contact = validContacts[i]
    
    try {
      // Personalizar mensagem com vari√°veis
      let personalizedMessage = messageTemplate
      
      // Substituir todas as vari√°veis {{nome}}, {{email}}, etc
      Object.keys(contact.data).forEach(key => {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'gi')
        personalizedMessage = personalizedMessage.replace(regex, contact.data[key] || '')
      })

      // Enviar mensagem
      const result = await sendWhatsAppMessage(contact.phone, personalizedMessage)
      
      if (result.success) {
        successCount++
        console.log(`‚úÖ [${i + 1}/${validContacts.length}] Enviado para ${contact.phone}`)
      } else {
        failCount++
        console.error(`‚ùå [${i + 1}/${validContacts.length}] Falha para ${contact.phone}: ${result.error}`)
      }

      // Aguardar intervalo antes do pr√≥ximo envio (exceto no √∫ltimo)
      if (i < validContacts.length - 1) {
        await new Promise(resolve => setTimeout(resolve, delaySeconds * 1000))
      }

    } catch (error) {
      failCount++
      console.error(`‚ùå [${i + 1}/${validContacts.length}] Erro ao enviar para ${contact.phone}:`, error.message)
    }
  }

  console.log('\nüìä RELAT√ìRIO FINAL:')
  console.log(`   ‚úÖ Sucesso: ${successCount}`)
  console.log(`   ‚ùå Falhas: ${failCount}`)
  console.log(`   üì¶ Total: ${validContacts.length}`)

  // Notificar admin sobre conclus√£o
  if (NOTIFY_NUMBER) {
    const reportMessage = `üì¨ *ENVIO EM MASSA CONCLU√çDO*

üìä *Relat√≥rio:*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ Enviadas: ${successCount}
‚ùå Falhas: ${failCount}
üì¶ Total: ${validContacts.length}

‚è±Ô∏è Tempo estimado: ~${Math.ceil((validContacts.length * delaySeconds) / 60)} minutos

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
_AutoGiro - Sistema Automatizado_`

    try {
      await sendWhatsAppMessage(NOTIFY_NUMBER, reportMessage)
    } catch (err) {
      console.error('‚ö†Ô∏è Erro ao notificar admin:', err.message)
    }
  }
}

// ============================================
// WEBHOOK HUBLA
// ============================================
app.post('/webhook/hubla', async (req, res) => {
  try {
    console.log('üì• Webhook recebido da Hub.la')
    console.log('Type:', req.body?.type)

    // ========== VALIDAR TOKEN DE AUTENTICA√á√ÉO ==========
    if (HUBLA_WEBHOOK_TOKEN) {
      const receivedToken = req.headers['x-hubla-token'] || 
                           req.headers['x-hubla-signature'] || 
                           req.headers['authorization']?.replace('Bearer ', '') ||
                           req.body?.token

      console.log('üîê Validando token...')
      console.log('   Token esperado:', HUBLA_WEBHOOK_TOKEN.substring(0, 10) + '...')
      console.log('   Token recebido:', receivedToken ? receivedToken.substring(0, 10) + '...' : 'NENHUM')

      if (receivedToken !== HUBLA_WEBHOOK_TOKEN) {
        console.error('‚ùå Token inv√°lido ou ausente!')
        return res.status(401).json({
          success: false,
          error: 'Token de autentica√ß√£o inv√°lido ou ausente',
          hint: 'Envie o token no header x-hubla-token'
        })
      }
      
      console.log('‚úÖ Token validado com sucesso')
    } else {
      console.warn('‚ö†Ô∏è Webhook sem valida√ß√£o de token - configure HUBLA_WEBHOOK_TOKEN')
    }

    const eventType = req.body?.type

    // ========== SUBSCRIPTION ACTIVATED ==========
    if (eventType === 'subscription.activated') {
      const userData = mapHublaDataToUser(req.body)
      console.log('üë§ Dados mapeados:', {
        phone: userData.phone,
        name: userData.name,
        email: userData.email
      })

      const result = await createUserInDB(userData)

      if (result.success) {
        if (NOTIFY_NUMBER) {
          const adminMessage = formatUserCreatedMessage(result.user, req.body)
          await sendWhatsAppMessage(NOTIFY_NUMBER, adminMessage)
        }
        
        const welcomeMessage = formatWelcomeMessage(result.user, req.body)
        await sendWhatsAppMessage(result.user.phone, welcomeMessage)
        
        return res.status(200).json({
          success: true,
          message: result.code === 'ALREADY_EXISTS'
            ? 'Usu√°rio j√° existia e notifica√ß√µes enviadas'
            : 'Usu√°rio criado e notifica√ß√µes enviadas',
          user: result.user
        })
      } else {
        await notifyError(result.error, userData)
        return res.status(result.code === 'DUPLICATE_USER' ? 409 : 400).json({
          success: false,
          error: result.error,
          code: result.code
        })
      }
    }

    // ========== SUBSCRIPTION EXPIRING ==========
    if (eventType === 'subscription.expiring') {
      const webhookData = req.body
      const user = webhookData?.event?.user
      
      if (!user || !user.phone) {
        return res.status(400).json({
          success: false,
          error: 'Dados do usu√°rio ausentes no webhook'
        })
      }

      const cleanPhone = user.phone.replace(/\D/g, '')
      const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim()
      const subscription = webhookData?.event?.subscription
      const daysRemaining = subscription?.credits || 0

      console.log(`‚ö†Ô∏è Assinatura expirando para ${fullName} (${cleanPhone}) - ${daysRemaining} dias restantes`)

      const dbUser = await findUserByPhone(cleanPhone)
      
      if (dbUser) {
        const expiringMessage = formatExpiringMessage(
          { ...dbUser, name: fullName }, 
          webhookData
        )
        await sendWhatsAppMessage(cleanPhone, expiringMessage)

        if (NOTIFY_NUMBER) {
          const adminNotification = formatExpiringNotificationAdmin(
            { ...dbUser, name: fullName },
            webhookData
          )
          await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
        }

        return res.status(200).json({
          success: true,
          message: 'Notifica√ß√£o de expira√ß√£o enviada',
          user: {
            name: fullName,
            phone: cleanPhone,
            daysRemaining: daysRemaining
          }
        })
      } else {
        console.log(`‚ö†Ô∏è Usu√°rio n√£o encontrado no banco, mas enviando notifica√ß√£o de expira√ß√£o`)
        
        const tempUser = {
          name: fullName,
          phone: cleanPhone,
          email: user.email || 'N√£o informado'
        }

        const expiringMessage = formatExpiringMessage(tempUser, webhookData)
        await sendWhatsAppMessage(cleanPhone, expiringMessage)

        if (NOTIFY_NUMBER) {
          const adminNotification = formatExpiringNotificationAdmin(tempUser, webhookData)
          await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
        }

        return res.status(200).json({
          success: true,
          message: 'Notifica√ß√£o de expira√ß√£o enviada (usu√°rio n√£o cadastrado)',
          user: tempUser
        })
      }
    }

    // ========== SUBSCRIPTION DEACTIVATED ==========
    if (eventType === 'subscription.deactivated') {
      const webhookData = req.body
      const user = webhookData?.event?.user
      
      if (!user || !user.phone) {
        return res.status(400).json({
          success: false,
          error: 'Dados do usu√°rio ausentes no webhook'
        })
      }

      const cleanPhone = user.phone.replace(/\D/g, '')
      const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim()

      console.log(`üî¥ Assinatura DESATIVADA para ${fullName} (${cleanPhone})`)

      const dbUser = await findUserByPhone(cleanPhone)
      
      if (dbUser) {
        await deactivateUserInDB(cleanPhone)

        const deactivatedMessage = formatDeactivatedMessage(
          { ...dbUser, name: fullName }, 
          webhookData
        )
        await sendWhatsAppMessage(cleanPhone, deactivatedMessage)

        if (NOTIFY_NUMBER) {
          const adminNotification = formatDeactivatedNotificationAdmin(
            { ...dbUser, name: fullName },
            webhookData
          )
          await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
        }

        return res.status(200).json({
          success: true,
          message: 'Assinatura desativada e notifica√ß√µes enviadas',
          user: {
            id: dbUser.id,
            name: fullName,
            phone: cleanPhone,
            deactivated: true
          }
        })
      } else {
        console.log(`‚ö†Ô∏è Usu√°rio n√£o encontrado no banco para desativa√ß√£o`)
        
        const tempUser = {
          name: fullName,
          phone: cleanPhone,
          email: user.email || 'N√£o informado'
        }

        const deactivatedMessage = formatDeactivatedMessage(tempUser, webhookData)
        await sendWhatsAppMessage(cleanPhone, deactivatedMessage)

        if (NOTIFY_NUMBER) {
          const adminNotification = formatDeactivatedNotificationAdmin(tempUser, webhookData)
          await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
        }

        return res.status(200).json({
          success: true,
          message: 'Notifica√ß√£o de desativa√ß√£o enviada (usu√°rio n√£o cadastrado)',
          user: tempUser
        })
      }
    }

    // ========== CARRINHO ABANDONADO ==========
    if (eventType === 'lead.abandoned_checkout' || eventType === 'AbandonedCheckout') {
      console.log('üõí Processando carrinho abandonado...')
      console.log('üì¶ Payload completo:', JSON.stringify(req.body, null, 2))
      
      const webhookData = req.body
      const eventData = webhookData.event

      const lead = {
        fullName: eventData.userName,
        phone: eventData.userPhone,
        email: eventData.userEmail,
        id: eventData.userId || 'N/A',
        session: {
          url: eventData.checkoutUrl || 'N/A' 
        }
      }

      const products = eventData.productName ? [{ name: eventData.productName, id: eventData.productId }] : []
      
      console.log('üë§ Lead encontrado:', lead ? 'SIM' : 'N√ÉO')
      console.log('üì± Telefone do lead:', lead?.phone)
      
      if (!lead || !lead.phone) {
        console.error('‚ùå Valida√ß√£o falhou: dados do lead ausentes')
        return res.status(400).json({
          success: false,
          error: 'Dados do lead ausentes no webhook',
          received: {
            hasLead: !!lead,
            hasPhone: !!lead?.phone,
            leadData: lead
          }
        })
      }

      let cleanPhone = lead.phone.replace(/\D/g, '')

      // Garante que o n√∫mero de telefone tenha o c√≥digo do pa√≠s (55)
      if (cleanPhone.length >= 10 && cleanPhone.length <= 11) {
        cleanPhone = `55${cleanPhone}`
      }

      console.log(`üõí Carrinho abandonado: ${lead.fullName || 'Lead'} (${cleanPhone})`)
      console.log(`üì¶ Produtos: ${products.map(p => p.name).join(', ')}`)

      const recoveryMessage = formatAbandonedCheckoutMessage(lead, products)
      await sendWhatsAppMessage(cleanPhone, recoveryMessage)

      if (NOTIFY_NUMBER) {
        const adminNotification = formatAbandonedCheckoutNotificationAdmin(lead, products, webhookData)
        await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
      }

      return res.status(200).json({
        success: true,
        message: 'Mensagem de recupera√ß√£o de carrinho enviada',
        lead: {
          name: lead.fullName,
          phone: cleanPhone,
          email: lead.email,
          products: products.map(p => p.name)
        }
      })
    }

    // ========== OUTROS EVENTOS ==========
    console.log('‚ö†Ô∏è Evento ignorado:', eventType)
    return res.status(200).json({
      success: true,
      message: `Evento ${eventType} recebido mas n√£o processado`
    })

  } catch (error) {
    console.error('‚ùå Erro no webhook:', error)
    await notifyError(error.message, req.body)
    return res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: error.message
    })
  }
})

// ============================================
// ROTAS DE TESTE
// ============================================
app.post('/test/create-user', async (req, res) => {
  try {
    console.log('üß™ Teste manual de cria√ß√£o de usu√°rio')

    const phone = (req.body.phone || '11999999999').replace(/\D/g, '')
    const name = req.body.name || 'Usu√°rio Teste'
    
    if (!/^\d{10,15}$/.test(phone)) {
      return res.status(400).json({ success: false, error: 'Telefone inv√°lido' })
    }

    const userData = {
      phone,
      password: req.body.password || 'teste123',
      name,
      email: req.body.email || 'teste@email.com',
      clientId: req.body.clientId || 'client1',
      credits: Number(req.body.credits || 0)
    }

    const result = await createUserInDB(userData)

    if (result.success) {
      if (NOTIFY_NUMBER) {
        const fakeWebhook = {
          event: {
            product: { name: 'Produto Teste' },
            subscription: {
              credits: userData.credits,
              paymentMethod: 'credit_card',
              autoRenew: true
            }
          }
        }
        const message = formatUserCreatedMessage(result.user, fakeWebhook)
        await sendWhatsAppMessage(NOTIFY_NUMBER, message)
      }

      return res.json({
        success: true,
        message: 'Usu√°rio teste criado com sucesso',
        user: result.user
      })
    } else {
      return res.status(400).json(result)
    }
  } catch (error) {
    return res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

app.post('/test/expiring', async (req, res) => {
  try {
    console.log('üß™ Teste manual de assinatura expirando')

    const phone = (req.body.phone || '11999999999').replace(/\D/g, '')
    const name = req.body.name || 'Usu√°rio Teste'
    const daysRemaining = Number(req.body.daysRemaining || 3)
    const autoRenew = req.body.autoRenew !== false
    
    if (!/^\d{10,15}$/.test(phone)) {
      return res.status(400).json({ success: false, error: 'Telefone inv√°lido' })
    }

    const fakeWebhook = {
      type: 'subscription.expiring',
      event: {
        product: {
          id: 'test-product-id',
          name: 'Produto Teste'
        },
        subscription: {
          id: 'test-subscription-id',
          credits: daysRemaining,
          autoRenew: autoRenew,
          paymentMethod: 'credit_card'
        },
        user: {
          id: 'test-user-id',
          firstName: name.split(' ')[0],
          lastName: name.split(' ').slice(1).join(' '),
          phone: phone,
          email: req.body.email || 'teste@email.com'
        }
      }
    }

    const dbUser = await findUserByPhone(phone)
    
    const userForMessage = dbUser || {
      name: name,
      phone: phone,
      email: req.body.email || 'teste@email.com'
    }

    const expiringMessage = formatExpiringMessage(userForMessage, fakeWebhook)
    await sendWhatsAppMessage(phone, expiringMessage)

    if (NOTIFY_NUMBER) {
      const adminNotification = formatExpiringNotificationAdmin(userForMessage, fakeWebhook)
      await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
    }

    return res.json({
      success: true,
      message: 'Teste de expira√ß√£o enviado',
      user: {
        name: name,
        phone: phone,
        daysRemaining: daysRemaining,
        autoRenew: autoRenew,
        existsInDB: !!dbUser
      }
    })
  } catch (error) {
    console.error('‚ùå Erro no teste:', error)
    return res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

app.post('/test/deactivated', async (req, res) => {
  try {
    console.log('üß™ Teste manual de assinatura desativada')

    const phone = (req.body.phone || '11999999999').replace(/\D/g, '')
    const name = req.body.name || 'Usu√°rio Teste'
    
    if (!/^\d{10,15}$/.test(phone)) {
      return res.status(400).json({ success: false, error: 'Telefone inv√°lido' })
    }

    const fakeWebhook = {
      type: 'subscription.deactivated',
      event: {
        product: {
          id: 'test-product-id',
          name: 'Produto Teste'
        },
        subscription: {
          id: 'test-subscription-id',
          credits: 0,
          status: 'inactive',
          autoRenew: false,
          paymentMethod: 'credit_card',
          inactivatedAt: new Date().toISOString()
        },
        user: {
          id: 'test-user-id',
          firstName: name.split(' ')[0],
          lastName: name.split(' ').slice(1).join(' '),
          phone: phone,
          email: req.body.email || 'teste@email.com'
        }
      }
    }

    const dbUser = await findUserByPhone(phone)
    
    if (dbUser) {
      await deactivateUserInDB(phone)
    }

    const userForMessage = dbUser || {
      name: name,
      phone: phone,
      email: req.body.email || 'teste@email.com'
    }

    const deactivatedMessage = formatDeactivatedMessage(userForMessage, fakeWebhook)
    await sendWhatsAppMessage(phone, deactivatedMessage)

    if (NOTIFY_NUMBER) {
      const adminNotification = formatDeactivatedNotificationAdmin(userForMessage, fakeWebhook)
      await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
    }

    return res.json({
      success: true,
      message: 'Teste de desativa√ß√£o enviado',
      user: {
        name: name,
        phone: phone,
        deactivated: true,
        existsInDB: !!dbUser
      }
    })
  } catch (error) {
    console.error('‚ùå Erro no teste:', error)
    return res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

app.post('/test/abandoned-checkout', async (req, res) => {
  try {
    console.log('üß™ Teste manual de carrinho abandonado')

    const phone = (req.body.phone || '11999999999').replace(/\D/g, '')
    const fullName = req.body.name || 'Jo√£o da Silva'
    const email = req.body.email || 'teste@email.com'
    const productName = req.body.productName || 'Assinatura AutoGiro Premium'
    
    if (!/^\d{10,15}$/.test(phone)) {
      return res.status(400).json({ success: false, error: 'Telefone inv√°lido' })
    }

    const fakeWebhook = {
      type: 'lead.abandoned_checkout',
      event: {
        products: [{
          id: 'test-product-id',
          name: productName,
          offers: [{
            id: 'test-offer-id',
            name: 'Principal'
          }]
        }],
        lead: {
          id: 'test-lead-' + Date.now(),
          fullName: fullName,
          email: email,
          phone: phone,
          session: {
            url: 'https://pay.hub.la/test-checkout-url',
            utm: {
              source: req.body.utmSource || 'whatsapp',
              medium: req.body.utmMedium || 'direct',
              campaign: req.body.utmCampaign || 'recuperacao',
              content: 'teste',
              term: 'teste'
            }
          },
          createdAt: new Date().toISOString()
        }
      },
      version: '2.0.0'
    }

    const lead = fakeWebhook.event.lead
    const products = fakeWebhook.event.products

    const recoveryMessage = formatAbandonedCheckoutMessage(lead, products)
    await sendWhatsAppMessage(phone, recoveryMessage)

    if (NOTIFY_NUMBER) {
      const adminNotification = formatAbandonedCheckoutNotificationAdmin(lead, products, fakeWebhook)
      await sendWhatsAppMessage(NOTIFY_NUMBER, adminNotification)
    }

    return res.json({
      success: true,
      message: 'Teste de carrinho abandonado enviado',
      lead: {
        name: fullName,
        phone: phone,
        email: email,
        product: productName
      }
    })
  } catch (error) {
    console.error('‚ùå Erro no teste:', error)
    return res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// ============================================
// INICIALIZAR SERVIDOR
// ============================================
async function start() {
  try {
    console.log('üöÄ Inicializando AutoGiro com Baileys...')
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')

    console.log('üîç Testando conex√£o com banco...')
    await pool.query('SELECT NOW()')
    console.log('‚úÖ Banco conectado!')

    app.listen(PORT, () => {
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')
      console.log(`‚úÖ Servidor na porta ${PORT}`)
      console.log(`üì° Webhook: http://localhost:${PORT}/webhook/hubla`)
      console.log(`üß™ Teste Cria√ß√£o: http://localhost:${PORT}/test/create-user`)
      console.log(`üß™ Teste Expira√ß√£o: http://localhost:${PORT}/test/expiring`)
      console.log(`üß™ Teste Desativa√ß√£o: http://localhost:${PORT}/test/deactivated`)
      console.log(`üß™ Teste Carrinho: http://localhost:${PORT}/test/abandoned-checkout`)
      console.log(`üìä Status: http://localhost:${PORT}/status`)
      console.log(`üñ•Ô∏è  Dashboard: http://localhost:${PORT}/dashboard`)
      console.log(`üì¨ Envio em Massa: http://localhost:${PORT}/dashboard (aba Envio em Massa)`)
      console.log(`üìû Notifica√ß√µes: +${NOTIFY_NUMBER}`)
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n')
      
      initWhatsApp(false).catch(err => {
        console.error('‚ùå Erro ao iniciar WhatsApp:', err)
        scheduleReconnect(10000)
      })
    })
  } catch (error) {
    console.error('‚ùå Erro fatal:', error)
    process.exit(1)
  }
}

async function shutdown(signal) {
  console.log(`\n‚èπÔ∏è Recebido ${signal}, encerrando...`)
  
  try {
    isWhatsappReady = false
    if (sock) {
      sock.end(undefined)
      console.log('üü¢ WhatsApp encerrado')
    }
  } catch (e) {
    console.warn('‚ö†Ô∏è Erro ao encerrar WhatsApp:', e?.message)
  }
  
  try {
    await pool.end()
    console.log('üü¢ Banco encerrado')
  } catch (e) {
    console.warn('‚ö†Ô∏è Erro ao encerrar banco:', e?.message)
  }
  
  process.exit(0)
}

process.on('SIGINT', () => shutdown('SIGINT'))
process.on('SIGTERM', () => shutdown('SIGTERM'))

start()
